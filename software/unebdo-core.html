from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, List
from datetime import datetime, timezone
import re
import hashlib

from .canonical import canonical_bytes
from .crypto import import_public_key_hex, verify

HEX128 = re.compile(r"^[0-9a-f]{128}$")

@dataclass
class OpcDecision:
    decision: str  # "ALLOW" | "DENY"
    reasons: List[str]
    checked_at: str

def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def evaluate_manifest(manifest: Dict[str, Any]) -> OpcDecision:
    """
    OPC STRONG (v0.2)
    - FAIL-CLOSED
    - verifica struttura
    - verifica hash SHA-512
    - verifica firma Ed25519
    """

    reasons: List[str] = []

    if not isinstance(manifest, dict):
        return OpcDecision("DENY", ["manifest_not_object"], _now_iso())

    # ===== campi minimi =====
    if "unebdo_version" not in manifest:
        reasons.append("missing_unebdo_version")
    if "prev_hash" not in manifest:
        reasons.append("missing_prev_hash")
    if "event" not in manifest:
        reasons.append("missing_event")
    if "trace" not in manifest:
        reasons.append("missing_trace")

    prev_hash = manifest.get("prev_hash", "")
    if not isinstance(prev_hash, str) or not HEX128.match(prev_hash):
        reasons.append("invalid_prev_hash")

    event = manifest.get("event")
    if not isinstance(event, dict):
        reasons.append("event_not_object")
    else:
        if "type" not in event:
            reasons.append("missing_event_type")
        if "ts" not in event:
            reasons.append("missing_event_ts")
        if "subject_id" not in event:
            reasons.append("missing_subject_id")

    trace = manifest.get("trace", {})
    if not isinstance(trace, dict):
        reasons.append("trace_not_object")
        trace = {}

    manifest_sha512 = trace.get("manifest_sha512")
    signature_hex = trace.get("signature")
    public_key_hex = trace.get("public_key")

    if not isinstance(manifest_sha512, str) or len(manifest_sha512) == 0:
        reasons.append("missing_manifest_sha512")
    if not isinstance(signature_hex, str) or len(signature_hex) == 0:
        reasons.append("missing_signature")
    if not isinstance(public_key_hex, str) or len(public_key_hex) == 0:
        reasons.append("missing_public_key")

    # FAIL-CLOSED se struttura non valida
    if reasons:
        return OpcDecision("DENY", reasons, _now_iso())

    # ===== verifica hash =====
    canon = canonical_bytes(manifest)
    real_hash = hashlib.sha512(canon).hexdigest()
    if real_hash != manifest_sha512:
        reasons.append("manifest_hash_mismatch")

    # ===== verifica firma =====
    try:
        vk = import_public_key_hex(public_key_hex)
        sig_bytes = bytes.fromhex(signature_hex)
        if not verify(vk, canon, sig_bytes):
            reasons.append("signature_invalid")
    except Exception:
        reasons.append("signature_verification_error")

    decision = "ALLOW" if not reasons else "DENY"
    return OpcDecision(decision, reasons, _now_iso())

import hashlib
import json
from dataclasses import dataclass
from typing import Any, Dict

from .canonical import canonical_json
from .crypto import (
    new_keypair,
    sign,
    export_public_key_hex,
)

def sha512_hex(data: bytes) -> str:
    return hashlib.sha512(data).hexdigest()

@dataclass
class ProofBundle:
    manifest: Dict[str, Any]
    manifest_canonical: str
    manifest_hash: str
    signature_hex: str
    public_key_hex: str

def build_manifest(event: Dict[str, Any], prev_hash: str) -> Dict[str, Any]:
    return {
        "unebdo_version": "0.2.0",
        "prev_hash": prev_hash,
        "event": event,
        "trace": {
            "manifest_sha512": "",
            "signature": "",
            "public_key": ""
        }
    }

def mint(event: Dict[str, Any], prev_hash: str = "0"*128) -> ProofBundle:
    manifest = build_manifest(event, prev_hash)

    # 1) canonicalizza con trace vuoto
    canon_tmp = canonical_json(manifest)
    hash_tmp = sha512_hex(canon_tmp.encode("utf-8"))

    # 2) firma
    sk, vk = new_keypair()
    signature = sign(sk, canon_tmp.encode("utf-8"))

    # 3) scrivi trace
    manifest["trace"]["manifest_sha512"] = hash_tmp
    manifest["trace"]["signature"] = signature.hex()
    manifest["trace"]["public_key"] = export_public_key_hex(vk)

    # 4) canonicalizza finale + hash finale
    canon_final = canonical_json(manifest)
    hash_final = sha512_hex(canon_final.encode("utf-8"))
    manifest["trace"]["manifest_sha512"] = hash_final

    return ProofBundle(
        manifest=manifest,
        manifest_canonical=canon_final,
        manifest_hash=hash_final,
        signature_hex=manifest["trace"]["signature"],
        public_key_hex=manifest["trace"]["public_key"],
    )

from unebdo.core import mint
from unebdo.opc import evaluate_manifest

def test_opc_allow_valid_manifest():
    event = {
        "type": "demo",
        "ts": "2026-01-21T12:00:00Z",
        "subject_id": "IPR-HBCE-000",
        "payload": {"x": 1}
    }
    bundle = mint(event)
    decision = evaluate_manifest(bundle.manifest)
    assert decision.decision == "ALLOW"

def test_opc_deny_tampered_manifest():
    event = {
        "type": "demo",
        "ts": "2026-01-21T12:00:00Z",
        "subject_id": "IPR-HBCE-000",
        "payload": {"x": 1}
    }
    bundle = mint(event)

    # manomissione
    bundle.manifest["event"]["payload"]["x"] = 999

    decision = evaluate_manifest(bundle.manifest)
    assert decision.decision == "DENY"
